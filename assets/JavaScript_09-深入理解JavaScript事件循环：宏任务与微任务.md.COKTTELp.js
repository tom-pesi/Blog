import{_ as s,c as a,o as i,a2 as t}from"./chunks/framework.Dez3CbjC.js";const g=JSON.parse('{"title":"简单理解 JavaScript 事件循环：宏任务与微任务","description":"","frontmatter":{},"headers":[],"relativePath":"JavaScript/09-深入理解JavaScript事件循环：宏任务与微任务.md","filePath":"JavaScript/09-深入理解JavaScript事件循环：宏任务与微任务.md"}'),n={name:"JavaScript/09-深入理解JavaScript事件循环：宏任务与微任务.md"},l=t(`<h1 id="简单理解-javascript-事件循环-宏任务与微任务" tabindex="-1">简单理解 JavaScript 事件循环：宏任务与微任务 <a class="header-anchor" href="#简单理解-javascript-事件循环-宏任务与微任务" aria-label="Permalink to &quot;简单理解 JavaScript 事件循环：宏任务与微任务&quot;">​</a></h1><p>JavaScript 是一种单线程的语言，它使用事件循环来处理异步操作。在理解 JavaScript 中的事件循环时，有两个重要的概念：宏任务（macrotask）和微任务（microtask）。本文将深入探讨这些概念，以及它们在 JavaScript 中的应用。</p><h3 id="_1-事件循环-event-loop" tabindex="-1">1. 事件循环（Event Loop） <a class="header-anchor" href="#_1-事件循环-event-loop" aria-label="Permalink to &quot;1. 事件循环（Event Loop）&quot;">​</a></h3><p>事件循环是 JavaScript 中处理异步操作的机制。它允许 JavaScript 引擎在执行完当前任务后，检查任务队列中是否有待处理的任务。如果有，引擎会选择一个任务并执行，直到任务队列为空。</p><h3 id="_2-宏任务-macrotask" tabindex="-1">2. 宏任务（Macrotask） <a class="header-anchor" href="#_2-宏任务-macrotask" aria-label="Permalink to &quot;2. 宏任务（Macrotask）&quot;">​</a></h3><p>宏任务代表着一个独立的执行单元，它可以是一段脚本、用户交互、定时器事件或者网络请求等。在 JavaScript 中，宏任务队列通常包括了以下几种：</p><ul><li>脚本（整体代码）</li><li>setTimeout</li><li>setInterval</li><li>I/O 操作</li><li>UI 渲染</li></ul><p>当执行完一个宏任务后，事件循环会检查微任务队列是否为空，如果不为空，则立即执行微任务队列中的所有任务。</p><h3 id="_3-微任务-microtask" tabindex="-1">3. 微任务（Microtask） <a class="header-anchor" href="#_3-微任务-microtask" aria-label="Permalink to &quot;3. 微任务（Microtask）&quot;">​</a></h3><p>微任务是在当前任务执行完成后立即执行的任务，它们拥有更高的优先级，会在下一个事件循环之前执行完毕。常见的微任务包括：</p><ul><li>Promise 的回调函数</li><li>MutationObserver 的回调函数</li></ul><p>在 JavaScript 中，微任务的执行顺序优先于宏任务，这意味着在同一个事件循环中，微任务会优先于下一个宏任务执行。</p><h3 id="_4-示例代码" tabindex="-1">4. 示例代码 <a class="header-anchor" href="#_4-示例代码" aria-label="Permalink to &quot;4. 示例代码&quot;">​</a></h3><p>让我们通过一个简单的示例来理解事件循环中宏任务和微任务的执行顺序：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Script Start&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;setTimeout&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Promise&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Script End&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>输出结果将会是：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Script Start</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Script End</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">setTimeout</span></span></code></pre></div><h3 id="_5-总结" tabindex="-1">5. 总结 <a class="header-anchor" href="#_5-总结" aria-label="Permalink to &quot;5. 总结&quot;">​</a></h3><p>JavaScript 中的事件循环机制是理解异步编程的关键。通过了解宏任务和微任务的概念，我们可以更好地掌握 JavaScript 中异步代码的执行顺序。记住，宏任务和微任务的区别在于它们的执行时机和优先级，这对于编写高效、可靠的 JavaScript 代码至关重要。</p>`,19),p=[l];function e(h,k,r,o,E,c){return i(),a("div",null,p)}const _=s(n,[["render",e]]);export{g as __pageData,_ as default};
