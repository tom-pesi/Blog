import{_ as s,c as i,o as a,a2 as n}from"./chunks/framework.Dez3CbjC.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"gpt_csdn/04-Vue/04-Vue.js 模板编译深度解析：从模板到渲染函数的转化.md","filePath":"gpt_csdn/04-Vue/04-Vue.js 模板编译深度解析：从模板到渲染函数的转化.md"}'),t={name:"gpt_csdn/04-Vue/04-Vue.js 模板编译深度解析：从模板到渲染函数的转化.md"},p=n(`<h2 id="vue-js-模板编译深度解析-从模板到渲染函数的转化" tabindex="-1">Vue.js 模板编译深度解析：从模板到渲染函数的转化 <a class="header-anchor" href="#vue-js-模板编译深度解析-从模板到渲染函数的转化" aria-label="Permalink to &quot;Vue.js 模板编译深度解析：从模板到渲染函数的转化&quot;">​</a></h2><p>在 Vue.js 中，模板编译是一个核心过程，它将我们书写的模板转换为渲染函数，最终渲染成实际的 DOM。这个过程在 Vue 的响应式系统中起着至关重要的作用。本文将深入探讨 Vue.js 模板编译的过程，了解其背后进行的操作以及如何影响 Vue 的运行效率和性能。</p><h3 id="模板编译概述" tabindex="-1">模板编译概述 <a class="header-anchor" href="#模板编译概述" aria-label="Permalink to &quot;模板编译概述&quot;">​</a></h3><p>在 Vue.js 中，模板编译可以分为三个主要阶段：</p><ol><li><strong>解析（Parsing）</strong>：将模板字符串解析为抽象语法树（AST）。</li><li><strong>优化（Optimization）</strong>：遍历 AST，标记静态节点，以便在后续的渲染中跳过不需要变化的部分。</li><li><strong>代码生成（Code Generation）</strong>：将优化后的 AST 转换为渲染函数。</li></ol><h3 id="解析-parsing" tabindex="-1">解析（Parsing） <a class="header-anchor" href="#解析-parsing" aria-label="Permalink to &quot;解析（Parsing）&quot;">​</a></h3><p>解析阶段是将模板字符串转换为 AST 的过程。AST 是模板的抽象语法表示，它描述了模板的结构和内容。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> template</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&lt;div&gt;{{ message }}&lt;/div&gt;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ast</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(template);</span></span></code></pre></div><p>解析阶段通常包括以下步骤：</p><ul><li><strong>词法分析（Lexical Analysis）</strong>：将模板字符串分解为一系列的令牌（tokens）。</li><li><strong>语法分析（Syntax Analysis）</strong>：根据令牌生成 AST 节点，并建立节点之间的关系。</li></ul><p>Vue.js 使用一个递归下降解析器来解析模板。每个解析函数处理模板的不同部分（如标签、属性、文本等），并构建相应的 AST 节点。</p><h3 id="优化-optimization" tabindex="-1">优化（Optimization） <a class="header-anchor" href="#优化-optimization" aria-label="Permalink to &quot;优化（Optimization）&quot;">​</a></h3><p>优化阶段的主要目标是通过标记静态节点，减少渲染函数的执行开销。静态节点在渲染过程中不会发生变化，因此可以在初次渲染后直接复用。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">optimize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ast);</span></span></code></pre></div><p>在优化过程中，Vue.js 会遍历整个 AST，并为每个节点打上静态标记。主要的优化操作包括：</p><ul><li><strong>标记静态根节点</strong>：静态根节点是包含静态子树的节点。</li><li><strong>跳过静态子树</strong>：在后续的渲染中，可以跳过这些静态子树，从而提升渲染性能。</li></ul><h3 id="代码生成-code-generation" tabindex="-1">代码生成（Code Generation） <a class="header-anchor" href="#代码生成-code-generation" aria-label="Permalink to &quot;代码生成（Code Generation）&quot;">​</a></h3><p>代码生成阶段是将优化后的 AST 转换为渲染函数的过程。渲染函数是用于创建 VNode（虚拟节点）的函数，最终会被 Vue 渲染成实际的 DOM。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> code</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> generate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ast);</span></span></code></pre></div><p>代码生成主要包括以下步骤：</p><ul><li><strong>生成渲染函数代码</strong>：将 AST 转换为 JavaScript 渲染函数代码。</li><li><strong>生成静态渲染函数</strong>：为静态节点生成专用的渲染函数，以便复用。</li></ul><p>生成的渲染函数类似于以下结构：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  with</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> _c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_v</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(message))])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="模板编译的具体实现" tabindex="-1">模板编译的具体实现 <a class="header-anchor" href="#模板编译的具体实现" aria-label="Permalink to &quot;模板编译的具体实现&quot;">​</a></h3><p>我们可以通过分析 Vue.js 的源码，深入了解模板编译的具体实现。以下是 Vue.js 模板编译的关键源码片段：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { parse } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./parser/index&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { optimize } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./optimizer&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { generate } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./codegen/index&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ast</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(template.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">trim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), options);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (options.optimize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    optimize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ast, options);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> code</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> generate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ast, options);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ast,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    render: code.render,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    staticRenderFns: code.staticRenderFns</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在 <code>compile</code> 函数中，我们可以看到整个编译过程的三个主要阶段：解析、优化和代码生成。</p><h3 id="实际应用中的模板编译" tabindex="-1">实际应用中的模板编译 <a class="header-anchor" href="#实际应用中的模板编译" aria-label="Permalink to &quot;实际应用中的模板编译&quot;">​</a></h3><p>在实际应用中，模板编译通常发生在构建阶段（例如通过 vue-loader），这样可以在运行时直接使用预编译的渲染函数，提升应用的性能。</p><h4 id="预编译模板" tabindex="-1">预编译模板 <a class="header-anchor" href="#预编译模板" aria-label="Permalink to &quot;预编译模板&quot;">​</a></h4><p>在构建工具（如 Webpack）中，使用 vue-loader 可以将 .vue 文件中的模板预编译为渲染函数：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// webpack.config.js</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  module: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rules: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        test:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">vue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        loader: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;vue-loader&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>通过预编译，我们可以在运行时直接使用渲染函数，避免了模板编译的开销：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { render, staticRenderFns } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./MyComponent.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  render</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$mount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#app&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h3><p>通过本文的介绍，我们深入了解了 Vue.js 模板编译的过程及其背后进行的操作。模板编译包括解析、优化和代码生成三个主要阶段，每个阶段都为最终的渲染效率和性能优化做出了重要贡献。</p><p>理解模板编译的过程，不仅有助于我们编写更高效的 Vue.js 代码，还能帮助我们在需要时进行更深层次的优化和调试。希望通过本文的介绍，你对 Vue.js 的模板编译有了更深入的理解，并能在实际项目中灵活运用这些知识。Happy coding!</p>`,37),l=[p];function e(h,k,r,d,E,o){return a(),i("div",null,l)}const y=s(t,[["render",e]]);export{c as __pageData,y as default};
